diff --git a/tradingview_webhook.py b/tradingview_webhook.py
new file mode 100644
index 0000000..e69de29
--- /dev/null
+++ b/tradingview_webhook.py
@@ -0,0 +1,13 @@
+# tradingview_webhook.py (repo root) - shim that re-exports the canonical blueprint
+try:
+    # Prefer the src-based canonical module
+    from src.trading.tradingview_webhook import bp as bp, tradingview_blueprint as tradingview_blueprint
+except Exception as e:
+    # Fallback to web module if src import not present
+    try:
+        from web.tradingview_webhook import bp as bp, tradingview_blueprint as tradingview_blueprint
+    except Exception as e2:
+        raise ImportError("tradingview_webhook shim: failed to import tradingview blueprint: " + repr((e, e2)))
+
diff --git a/web/tradingview_webhook.py b/web/tradingview_webhook.py
index e69de29..e3f8a2c 100644
--- a/web/tradingview_webhook.py
+++ b/web/tradingview_webhook.py
@@ -1,67 +1,67 @@
-from flask import Flask, jsonify, request
-import logging
-import os
-import sys
-
-# --- Add vendor path for Coinbase client ---
-sys.path.append(os.path.join(os.path.dirname(__file__), "../vendor/coinbase_advanced_py"))
-
-try:
-    from coinbase_advanced_py.client import Client
-    COINBASE_AVAILABLE = True
-except ImportError:
-    logging.warning("⚠️ Coinbase client not found, live trading disabled")
-    COINBASE_AVAILABLE = False
-
-# --- Flask app ---
-app = Flask(__name__)
-logging.basicConfig(level=logging.INFO)
-
-# --- Health check endpoint ---
-@app.route("/health", methods=["GET"])
-def health():
-    return "OK", 200
-
-# --- TradingView webhook blueprint ---
-try:
-    from tradingview_webhook import tradingview_blueprint
-    app.register_blueprint(tradingview_blueprint, url_prefix="/tv")
-    logging.info("✅ TradingView blueprint registered")
-except Exception as e:
-    logging.warning(f"⚠️ Could not register TradingView blueprint: {e}")
-
-# --- Minimal live Coinbase connection check ---
-def init_coinbase():
-    if not COINBASE_AVAILABLE:
-        return None
-
-    api_key = os.getenv("COINBASE_API_KEY")
-    api_secret = os.getenv("COINBASE_API_SECRET")
-    api_sub = os.getenv("COINBASE_API_SUB")
-
-    if not all([api_key, api_secret, api_sub]):
-        logging.warning("⚠️ Coinbase API credentials missing, skipping live setup")
-        return None
-
-    try:
-        client = Client(api_key, api_secret, api_sub)
-        accounts = client.get_accounts()  # test connection
-        logging.info(f"✅ Coinbase connection OK, accounts: {accounts}")
-        return client
-    except Exception as e:
-        logging.error(f"❌ Coinbase connection failed: {e}")
-        return None
-
-coinbase_client = init_coinbase()
-
-# --- Example live endpoint ---
-@app.route("/trade/status", methods=["GET"])
-def trade_status():
-    if not coinbase_client:
-        return jsonify({"status": "Coinbase not connected"}), 503
-    try:
-        accounts = coinbase_client.get_accounts()
-        return jsonify({"status": "live", "accounts": accounts})
-    except Exception as e:
-        return jsonify({"status": "error", "message": str(e)}), 500
+from flask import Flask, jsonify, request
+import logging
+import os
+import sys
+
+# --- Add vendor path for Coinbase client ---
+sys.path.append(os.path.join(os.path.dirname(__file__), "../vendor/coinbase_advanced_py"))
+
+try:
+    from coinbase_advanced_py.client import Client
+    COINBASE_AVAILABLE = True
+except ImportError:
+    logging.warning("⚠️ Coinbase client not found, live trading disabled")
+    COINBASE_AVAILABLE = False
+
+# --- Flask app ---
+app = Flask(__name__)
+logging.basicConfig(level=logging.INFO)
+
+# --- Health check endpoint ---
+@app.route("/health", methods=["GET"])
+def health():
+    return "OK", 200
+
+# --- TradingView webhook blueprint ---
+try:
+    # Import the blueprint from the module that actually defines it to avoid
+    # circular imports / shim mismatches.
+    from src.trading.tradingview_webhook import tradingview_blueprint
+    app.register_blueprint(tradingview_blueprint, url_prefix="/tv")
+    logging.info("✅ TradingView blueprint registered")
+except Exception as e:
+    logging.warning(f"⚠️ Could not register TradingView blueprint: {e}")
+
+# --- Minimal live Coinbase connection check ---
+def init_coinbase():
+    if not COINBASE_AVAILABLE:
+        return None
+
+    api_key = os.getenv("COINBASE_API_KEY")
+    api_secret = os.getenv("COINBASE_API_SECRET")
+    api_sub = os.getenv("COINBASE_API_SUB")
+
+    if not all([api_key, api_secret, api_sub]):
+        logging.warning("⚠️ Coinbase API credentials missing, skipping live setup")
+        return None
+
+    try:
+        client = Client(api_key, api_secret, api_sub)
+        accounts = client.get_accounts()  # test connection
+        logging.info(f"✅ Coinbase connection OK, accounts: {accounts}")
+        return client
+    except Exception as e:
+        logging.error(f"❌ Coinbase connection failed: {e}")
+        return None
+
+coinbase_client = init_coinbase()
+
+# --- Example live endpoint ---
+@app.route("/trade/status", methods=["GET"])
+def trade_status():
+    if not coinbase_client:
+        return jsonify({"status": "Coinbase not connected"}), 503
+    try:
+        accounts = coinbase_client.get_accounts()
+        return jsonify({"status": "live", "accounts": accounts})
+    except Exception as e:
+        return jsonify({"status": "error", "message": str(e)}), 500
+
diff --git a/Dockerfile b/Dockerfile
new file mode 100644
index 0000000..e69de29
--- /dev/null
+++ b/Dockerfile
@@ -0,0 +1,120 @@
+# Multi-stage Dockerfile — tolerant installer (Poetry or fallback to pip and local package)
+# Stage 1: Builder
+FROM python:3.12-slim AS builder
+
+ENV POETRY_VERSION=1.7.1 \
+    POETRY_NO_INTERACTION=1 \
+    POETRY_VIRTUALENVS_CREATE=false \
+    PYTHONUNBUFFERED=1 \
+    DEBIAN_FRONTEND=noninteractive
+
+WORKDIR /app
+
+# Install build tools & Poetry (Poetry will be used only when appropriate)
+RUN apt-get update \
+ && apt-get install -y --no-install-recommends build-essential curl ca-certificates git \
+ && pip install --upgrade pip setuptools wheel \
+ && pip install --no-cache-dir "poetry==${POETRY_VERSION}" \
+ && apt-get clean \
+ && rm -rf /var/lib/apt/lists/*
+
+# Copy manifest files (pyproject + optional lock + common requirements)
+COPY pyproject.toml poetry.lock* requirements.txt requirements.bot.txt requirements.web.txt /app/
+
+# Copy full repo so local packages (setup.py / src/) are available for pip install fallback
+COPY . /app
+
+# If pyproject is Poetry-managed, run poetry; otherwise fallback to pip using requirements files
+RUN if [ -f /app/pyproject.toml ] && grep -q "^\[tool\.poetry\]" /app/pyproject.toml; then \
+      poetry config virtualenvs.create false && poetry install --no-root --no-dev ; \
+    else \
+      pip install --upgrade pip setuptools wheel && \
+      ( [ -f /app/requirements.txt ] && pip install --no-cache-dir -r /app/requirements.txt || true ) && \
+      ( [ -f /app/requirements.bot.txt ] && pip install --no-cache-dir -r /app/requirements.bot.txt || true ) && \
+      ( [ -f /app/requirements.web.txt ] && pip install --no-cache-dir -r /app/requirements.web.txt || true ) && \
+      pip install --no-cache-dir /app || true ; \
+    fi \
+ && rm -rf /root/.cache/pypoetry /root/.cache/pip
+
+# Stage 2: Final runtime
+FROM python:3.12-slim
+
+ENV PYTHONUNBUFFERED=1 \
+    PYTHONPATH=/app \
+    DEBIAN_FRONTEND=noninteractive
+
+WORKDIR /app
+
+# Runtime OS deps (adjust for your project's binary wheels)
+RUN apt-get update \
+ && apt-get install -y --no-install-recommends ca-certificates libpq5 libjpeg62-turbo zlib1g libssl3 \
+ && apt-get clean \
+ && rm -rf /var/lib/apt/lists/*
+
+# Copy installed python packages & scripts from builder
+COPY --from=builder /usr/local/lib/python3.12/site-packages /usr/local/lib/python3.12/site-packages
+COPY --from=builder /usr/local/bin /usr/local/bin
+
+# Copy application code
+COPY . /app
+
+# Create non-root user and chown
+RUN groupadd -r app && useradd -r -g app -d /app -s /sbin/nologin app \
+ && chown -R app:app /app /usr/local/bin /usr/local/lib/python3.12/site-packages
+
+USER app
+
+# Cleanup bytecode only (safe)
+RUN find /usr/local/lib/python3.12/site-packages -name "__pycache__" -type d -exec rm -rf {} + \
+ && find /usr/local/lib/python3.12/site-packages -name "*.pyc" -delete || true
+
+EXPOSE 5000
+
+# Adjust entrypoint to your project (web:app is used in this repo)
+CMD ["gunicorn", "web:app", "--bind", "0.0.0.0:5000"]
+
diff --git a/web/preflight.py b/web/preflight.py
new file mode 100644
index 0000000..e69de29
--- /dev/null
+++ b/web/preflight.py
@@ -0,0 +1,152 @@
+from flask import Blueprint, jsonify, current_app
+import os
+import traceback
+
+bp = Blueprint("preflight", __name__)
+
+def check_env():
+    required = {
+        "COINBASE_API_KEY": bool(os.getenv("COINBASE_API_KEY")),
+        "COINBASE_API_SECRET": bool(os.getenv("COINBASE_API_SECRET")),
+        "COINBASE_API_SUB": bool(os.getenv("COINBASE_API_SUB")),
+        "LIVE_TRADING": bool(os.getenv("LIVE_TRADING")),
+    }
+    return {"ok": all(required.values()), "detail": required}
+
+def check_imports():
+    try:
+        from src.nija_client import CoinbaseClient
+        return {"ok": True, "detail": "CoinbaseClient import OK"}
+    except Exception as e:
+        return {"ok": False, "detail": f"Import failed: {repr(e)}"}
+
+def check_auth_and_accounts():
+    try:
+        from src.nija_client import CoinbaseClient
+        client = CoinbaseClient()
+        accounts = client.get_accounts()
+        return {"ok": True, "detail": {"accounts_count": len(accounts), "sample": accounts[:3]}}
+    except Exception as e:
+        tb = traceback.format_exc()
+        return {"ok": False, "detail": f"Auth/accounts failed: {repr(e)}", "trace": tb}
+
+def check_funded_balance(min_usd=1.0):
+    try:
+        from src.nija_client import CoinbaseClient
+        client = CoinbaseClient()
+        accounts = client.get_accounts()
+        funded = []
+        for a in accounts:
+            try:
+                available = float(a.get("available", a.get("balance", {}).get("available", 0)))
+            except Exception:
+                available = 0.0
+            if available and available >= 0:
+                funded.append(a)
+        ok = any(True for a in funded)
+        return {"ok": ok, "detail": {"funded_count": len(funded), "sample": funded[:3]}}
+    except Exception as e:
+        tb = traceback.format_exc()
+        return {"ok": False, "detail": f"Balance check error: {repr(e)}", "trace": tb}
+
+def compute_score(results, weights=None):
+    default = {
+        "env": 10,
+        "imports": 10,
+        "auth": 20,
+        "accounts": 20,
+        "funded": 15,
+        "blueprint": 10,
+        "health": 15
+    }
+    if weights is None:
+        weights = default
+    total = sum(weights.values())
+    score = 0.0
+
+    if results.get("env", {}).get("ok"):
+        score += weights["env"]
+    if results.get("imports", {}).get("ok"):
+        score += weights["imports"]
+    if results.get("auth", {}).get("ok"):
+        score += weights["auth"]
+    if results.get("accounts", {}).get("ok"):
+        score += weights["accounts"]
+    if results.get("funded", {}).get("ok"):
+        score += weights["funded"]
+    if results.get("blueprint", {}).get("ok"):
+        score += weights["blueprint"]
+    if results.get("health", {}).get("ok"):
+        score += weights["health"]
+
+    percent = round((score / total) * 100, 1) if total else 0.0
+    return percent
+
+@bp.route("/preflight", methods=["GET"])
+def preflight():
+    results = {}
+    results["env"] = check_env()
+    results["imports"] = check_imports()
+    auth_accounts = check_auth_and_accounts()
+    results["auth"] = {"ok": auth_accounts["ok"], "detail": "auth/accounts attempt"}
+    results["accounts"] = {"ok": auth_accounts["ok"], "detail": auth_accounts.get("detail")}
+    results["funded"] = check_funded_balance()
+    try:
+        bp_names = [b.name for b in current_app.blueprints.values()]
+        results["blueprint"] = {"ok": "tradingview" in bp_names or "preflight" in bp_names, "detail": bp_names}
+    except Exception as e:
+        results["blueprint"] = {"ok": False, "detail": repr(e)}
+    try:
+        has_health = any("health" in rule.endpoint or rule.rule.endswith("/health") for rule in current_app.url_map.iter_rules())
+        results["health"] = {"ok": has_health, "detail": [r.rule for r in current_app.url_map.iter_rules() if "/health" in r.rule]}
+    except Exception as e:
+        results["health"] = {"ok": False, "detail": repr(e)}
+
+    percent = compute_score(results)
+    payload = {"ok": percent >= 80, "percent": percent, "results": results}
+    return jsonify(payload), (200 if percent >= 50 else 503)
+
diff --git a/scripts/prebuild-check.sh b/scripts/prebuild-check.sh
new file mode 100755
index 0000000..e69de29
--- /dev/null
+++ b/scripts/prebuild-check.sh
@@ -0,0 +1,18 @@
+#!/usr/bin/env bash
+set -euo pipefail
+echo "Running prebuild checks..."
+if [[ ! -f "pyproject.toml" ]]; then
+  echo "ERROR: pyproject.toml not found at repo root."
+  exit 1
+fi
+if grep -q "^\[tool\.poetry\]" pyproject.toml; then
+  echo "INFO: Poetry project detected."
+else
+  echo "INFO: No [tool.poetry] in pyproject.toml — will fall back to requirements files."
+fi
+echo "Prebuild checks passed."
+
diff --git a/.github/workflows/preflight-ci.yml b/.github/workflows/preflight-ci.yml
new file mode 100644
index 0000000..e69de29
--- /dev/null
+++ b/.github/workflows/preflight-ci.yml
@@ -0,0 +1,28 @@
+name: CI — preflight check & lint
+
+on:
+  push:
+    branches: [ main ]
+  pull_request:
+    branches: [ main ]
+
+jobs:
+  preflight:
+    runs-on: ubuntu-latest
+    steps:
+      - name: Checkout
+        uses: actions/checkout@v4
+
+      - name: Make scripts executable
+        run: chmod +x ./scripts/prebuild-check.sh
+
+      - name: Run prebuild checks
+        run: ./scripts/prebuild-check.sh
+
+      - name: Setup Python 3.12
+        uses: actions/setup-python@v4
+        with:
+          python-version: '3.12'
+
