# Organization-Wide Secret Scanning Policy

## Policy Overview

This document defines the centralized secret scanning rules and enforcement mechanisms for NIJA and related projects.

**Last Updated**: January 29, 2026  
**Version**: 1.0  
**Scope**: All NIJA repositories and projects

## Policy Statement

**All code, configuration, and documentation committed to NIJA repositories MUST be free of secrets, credentials, and sensitive data.**

This includes but is not limited to:
- API keys and secrets (Coinbase, Kraken, Alpaca, etc.)
- Private keys and certificates (SSH, SSL/TLS, PEM files)
- Authentication tokens (JWT, OAuth, session tokens)
- Database credentials (passwords, connection strings)
- Encryption keys (Fernet, AES, etc.)
- Webhook secrets
- Cloud provider credentials (AWS, GCP, Azure)

## Enforcement Layers

### Layer 1: Pre-Commit Hooks (Developer Machine)

**Required for all developers**

- Install: `pre-commit install`
- Runs before every commit
- Blocks commits containing secrets
- Immediate feedback to developers

**Tools**:
- detect-secrets (baseline-driven)
- gitleaks (comprehensive scanning)
- trufflehog (verified secrets only)
- Custom NIJA checks (API keys, PEM files, .env files)

**Configuration**: `.pre-commit-config.yaml`

### Layer 2: CI/CD Pipeline (GitHub Actions)

**Automatic enforcement on all pull requests and pushes**

- Runs on every PR and push to main/develop
- Cannot be bypassed by developers
- Scheduled weekly scans of entire repository
- Multiple redundant scanners for defense in depth

**Tools**:
- Gitleaks with `.gitleaks.toml` configuration
- TruffleHog with verified-only mode
- detect-secrets with baseline
- Pre-commit hook validation

**Workflows**:
- `.github/workflows/security-scan.yml`
- `.github/workflows/artifact-scanning.yml`

### Layer 3: GitHub Secret Scanning (Native)

**GitHub's built-in secret scanning**

- Enabled for all repositories
- Scans commits, issues, pull requests
- Partner patterns for major services
- Alerts to repository administrators

**Configuration**: Repository Settings → Security → Secret scanning

### Layer 4: Artifact Scanning

**Scan build artifacts and container images**

- Docker image scanning with Trivy and Grype
- Python package scanning with pip-audit
- SBOM (Software Bill of Materials) generation
- License compliance checking

**Workflow**: `.github/workflows/artifact-scanning.yml`

## Centralized Configuration

### Gitleaks Configuration (`.gitleaks.toml`)

**Organization-wide rules for all NIJA projects**

Custom rules for:
- Coinbase API keys and secrets
- Kraken API keys and secrets
- Alpaca API keys and secrets
- TradingView webhook secrets
- Fernet encryption keys
- Database passwords
- JWT secrets
- SSH private keys
- PEM certificates

**Allowlist**:
- Template files (`.env.example`, `.env.*_tier`)
- Documentation (`.md`, `.txt`)
- Archive directory
- Dependencies (`node_modules/`, `venv/`)

**Location**: Root of repository  
**Usage**: Shared across all NIJA projects

### detect-secrets Baseline (`.secrets.baseline`)

**Known false positives and exceptions**

- Generated by scanning repository
- Updated when legitimate patterns are flagged
- Reviewed and approved before baseline update

**Location**: Root of repository  
**Update**: `detect-secrets scan > .secrets.baseline`

### Bandit Configuration (`.bandit.yml`)

**Python security linting rules**

- Checks for common security issues
- Configured for NIJA project structure
- Excludes test files and archives
- Medium severity and confidence threshold

**Location**: Root of repository  
**Usage**: Pre-commit and CI

## Allowed Practices

### ✅ Configuration Templates

Template files that demonstrate structure:

```bash
# Allowed filenames
.env.example
.env.production.example
.env.*_tier (saver, investor, income, etc.)
```

**Requirements**:
- Use placeholder values only
- Document required format
- Never contain real credentials
- Committed to repository

### ✅ Documentation

Security documentation that references secrets:

```markdown
# Allowed in documentation
COINBASE_API_KEY=your_api_key_here
API_SECRET=<insert_your_secret>
```

**Requirements**:
- Use obvious placeholders
- Clearly marked as examples
- No real credential values

### ✅ Environment Variables

Runtime configuration:

```python
# Allowed in code
import os
api_key = os.environ.get('COINBASE_API_KEY')
```

**Requirements**:
- Load from environment at runtime
- Never hardcode values
- Use secret management system

## Prohibited Practices

### ❌ Hardcoded Credentials

```python
# NEVER DO THIS
COINBASE_API_KEY = "sk_live_abc123xyz789"
API_SECRET = "real_secret_value_here"
```

**Consequence**: Automatic commit block, CI failure

### ❌ .env Files with Real Secrets

```bash
# NEVER commit this file
.env
```

**Prevention**:
- `.gitignore` blocks `.env`
- Pre-commit hook blocks `.env` commits
- Use `.env.example` template instead

### ❌ Private Keys and Certificates

```bash
# NEVER commit these files
*.pem
*.key
*.crt
id_rsa
```

**Prevention**:
- Pre-commit hook blocks these extensions
- `.gitignore` excludes certificate files

### ❌ Binary Secrets

```python
# NEVER commit encrypted credentials
credentials.pkl
secrets.dat
encrypted_keys.bin
```

**Prevention**: Large file detection, manual review

## Incident Response

### If Secrets Are Detected

**Immediate Actions**:

1. **STOP**: Do not push the commit
2. **REMOVE**: Remove the secret from all files
3. **ROTATE**: Immediately rotate the exposed credential
4. **VERIFY**: Confirm secret is not in git history
5. **REPORT**: Notify security team

### If Secrets Reach GitHub

**Critical Actions** (within 1 hour):

1. **REVOKE**: Immediately revoke/rotate the exposed credential
2. **AUDIT**: Check for unauthorized access using the credential
3. **HISTORY**: Remove from git history using `git filter-branch` or BFG
4. **NOTIFY**: Alert security team and affected parties
5. **POSTMORTEM**: Document how it happened and prevention steps

**Tools**:
- [BFG Repo-Cleaner](https://rtyley.github.io/bfg-repo-cleaner/)
- [GitHub Docs: Removing sensitive data](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/removing-sensitive-data-from-a-repository)

### Credential Rotation Checklist

- [ ] Generate new credential with provider
- [ ] Update credential in secret management system
- [ ] Update all environments (dev, staging, production)
- [ ] Revoke old credential with provider
- [ ] Verify services using new credential
- [ ] Document incident and remediation

## Developer Onboarding

### Required Setup

All developers must:

1. Install pre-commit hooks:
   ```bash
   pip install pre-commit
   pre-commit install
   ```

2. Read security documentation:
   - [SECURITY.md](../SECURITY.md)
   - [PRE_COMMIT_SETUP.md](PRE_COMMIT_SETUP.md)
   - This policy document

3. Configure git to prevent accidents:
   ```bash
   # Never commit .env files globally
   git config --global core.excludesFile ~/.gitignore_global
   echo ".env" >> ~/.gitignore_global
   ```

4. Use approved secret management:
   - Environment variables for local development
   - GitHub Secrets for CI/CD
   - Encrypted vault for production

### Training Requirements

- Security awareness training
- Secret management best practices
- Incident response procedures
- Tool usage (pre-commit, gitleaks, etc.)

## Policy Compliance

### Repository Requirements

All NIJA repositories must have:

- [ ] `.pre-commit-config.yaml` configured
- [ ] `.gitleaks.toml` from organization template
- [ ] `.secrets.baseline` generated and maintained
- [ ] `.gitignore` excluding `.env` and credentials
- [ ] Security scanning CI workflows enabled
- [ ] README with security setup instructions
- [ ] SECURITY.md with contact information

### Audit Schedule

- **Daily**: CI/CD scans on all commits and PRs
- **Weekly**: Scheduled full repository scans
- **Monthly**: Manual security review of configurations
- **Quarterly**: Policy review and update
- **Annually**: Complete security audit

### Enforcement

**Violations**:
- Commit blocked by pre-commit hooks → Fix and retry
- CI failure → Cannot merge PR until resolved
- Secret leaked → Immediate credential rotation required
- Repeated violations → Additional training required

**Escalation**:
- First violation: Warning and guidance
- Second violation: Formal review
- Third violation: Access review
- Intentional bypass: Serious disciplinary action

## Policy Updates

This policy is a living document. Updates required for:

- New secret types discovered
- New tools or techniques available
- Incidents requiring policy changes
- Regulatory requirements
- Best practice evolution

**Update Process**:
1. Propose change via pull request
2. Security team review
3. Impact assessment
4. Communication to all developers
5. Update documentation and tools
6. Training if significant changes

## Support and Questions

**Security Team Contact**: security@nija.example.com (replace with actual)

**Resources**:
- [Pre-Commit Setup Guide](PRE_COMMIT_SETUP.md)
- [NIJA Security Documentation](../SECURITY.md)
- [GitHub Security Best Practices](https://docs.github.com/en/code-security)

**Tools Documentation**:
- [gitleaks](https://github.com/gitleaks/gitleaks)
- [detect-secrets](https://github.com/Yelp/detect-secrets)
- [trufflehog](https://github.com/trufflesecurity/trufflehog)
- [pre-commit](https://pre-commit.com/)

## Acknowledgments

This policy incorporates best practices from:
- OWASP Secrets Management Cheat Sheet
- GitHub Security Best Practices
- NIST Cybersecurity Framework
- Industry-standard secret scanning tools

---

**Remember**: Security is everyone's responsibility. If you see something, say something!

**Version History**:
- 1.0 (2026-01-29): Initial organization-wide policy
