#!/usr/bin/env bash
set -euo pipefail

# build_nija.sh - build the Nija Docker image using one of three strategies:
#   1) local  : use vendor/coinbase_advanced_py present in the build context
#   2) build-arg : clone vendor during build using --build-arg GITHUB_TOKEN (less secure)
#   3) buildkit  : clone vendor during build using BuildKit secret (recommended for private repos)
#
# Example usages:
#   ./build_nija.sh --mode local --target prod --tag nija:prod
#   ./build_nija.sh --mode build-arg --token "${GITHUB_TOKEN}" --target prod --tag nija:prod
#   ./build_nija.sh --mode buildkit --secret-file /path/to/tokenfile --target prod --tag nija:prod
#
# By default: target=prod, tag=nija:prod, mode=auto (prefers local if vendor exists,
# otherwise prefers buildkit if secret-file provided, otherwise build-arg if token provided)

show_help(){
  cat <<EOF
Usage: $0 [--mode local|build-arg|buildkit|auto] [--token TOKEN] [--secret-file PATH] [--target TARGET] [--tag IMAGE_TAG]

Modes:
  local     - expect vendor/coinbase_advanced_py in build context (recommended for reproducible builds)
  build-arg - clone during build using --build-arg (token may leak into build history; avoid for secrets)
  buildkit  - clone during build using BuildKit secret (preferred for private repos)

Examples:
  $0 --mode local
  $0 --mode build-arg --token "\$GITHUB_TOKEN" --target prod --tag nija:prod
  DOCKER_BUILDKIT=1 $0 --mode buildkit --secret-file ~/.github_token --target prod

EOF
}

# defaults
MODE="auto"
TARGET="prod"
TAG="nija:prod"
TOKEN=""
SECRET_FILE=""
DOCKERFILE_PATH="Dockerfile"

# parse args
while [ $# -gt 0 ]; do
  case "$1" in
    --mode) MODE="$2"; shift 2;;
    --token) TOKEN="$2"; shift 2;;
    --secret-file) SECRET_FILE="$2"; shift 2;;
    --target) TARGET="$2"; shift 2;;
    --tag) TAG="$2"; shift 2;;
    -h|--help) show_help; exit 0;;
    *) echo "Unknown arg: $1"; show_help; exit 2;;
  esac
done

# sanity checks
if [ ! -f "$DOCKERFILE_PATH" ]; then
  echo "ERROR: Dockerfile not found in current directory ($(pwd)). Run this from your repo root where Dockerfile lives."
  exit 1
fi

# determine mode if auto
if [ "$MODE" = "auto" ]; then
  if [ -d "vendor/coinbase_advanced_py" ]; then
    MODE="local"
  elif [ -n "${SECRET_FILE:-}" ] && [ -f "$SECRET_FILE" ]; then
    MODE="buildkit"
  elif [ -n "${TOKEN:-}" ]; then
    MODE="build-arg"
  else
    echo "ERROR: Could not auto-select build mode. Provide --mode or supply vendor/, --secret-file, or --token."
    show_help
    exit 1
  fi
fi

echo "Build mode: $MODE"
echo "Build target: $TARGET"
echo "Image tag: $TAG"

# ensure requirements.txt exists so Dockerfile COPY won't fail (create temp and remove later)
TMP_REQ_CREATED=0
if [ ! -f requirements.txt ]; then
  echo "# autogenerated placeholder" > requirements.txt
  TMP_REQ_CREATED=1
  echo "Created temporary requirements.txt to satisfy Dockerfile COPY"
fi

# assemble docker build command
DOCKER_BUILD_CMD=(docker build --progress=plain --target "$TARGET" -t "$TAG" .)

case "$MODE" in
  local)
    echo "Using local vendor/coinbase_advanced_py from build context."
    # nothing extra needed; local COPY will pick it up
    ;;

  "build-arg")
    if [ -z "${TOKEN:-}" ]; then
      echo "ERROR: --token required for build-arg mode (pass your GITHUB_TOKEN)."
      [ $TMP_REQ_CREATED -eq 1 ] && rm -f requirements.txt
      exit 1
    fi
    echo "Using build-arg cloning. WARNING: token may be exposed in image history."
    DOCKER_BUILD_CMD=(docker build --progress=plain --build-arg GITHUB_TOKEN="$TOKEN" --target "$TARGET" -t "$TAG" .)
    ;;

  "buildkit")
    if [ -z "${SECRET_FILE:-}" ] || [ ! -f "$SECRET_FILE" ]; then
      echo "ERROR: --secret-file path required for buildkit mode and must point to a readable file."
      [ $TMP_REQ_CREATED -eq 1 ] && rm -f requirements.txt
      exit 1
    fi
    # Inform user to use BuildKit env to enable --secret
    echo "Using BuildKit secret for cloning. Make sure to enable BuildKit when running the script:"
    echo "  DOCKER_BUILDKIT=1 $0 --mode buildkit --secret-file /path/to/tokenfile --target $TARGET --tag $TAG"
    echo "The script will invoke docker build with --secret if DOCKER_BUILDKIT=1 is set in the environment."
    # Build command will include the secret mount
    # If DOCKER_BUILDKIT is not set, docker will ignore --secret (and may error); we let the user control it.
    DOCKER_BUILD_CMD=(docker build --progress=plain --secret id=github_token,src="$SECRET_FILE" --target "$TARGET" -t "$TAG" .)
    ;;

  *)
    echo "ERROR: unknown mode: $MODE"
    [ $TMP_REQ_CREATED -eq 1 ] && rm -f requirements.txt
    exit 1
    ;;
esac

# print safe command (do not print token value)
SAFE_CMD=("${DOCKER_BUILD_CMD[@]}")
for i in "${!SAFE_CMD[@]}"; do
  if [ "${SAFE_CMD[$i]}" = "$TOKEN" ]; then
    SAFE_CMD[$i]="<REDACTED_TOKEN>"
  fi
done

echo "Running build command:"
printf ' %q' "${SAFE_CMD[@]}"
echo ""

# run the build
if [ "$MODE" = "buildkit" ]; then
  # advice: require DOCKER_BUILDKIT=1 or the build may not accept --secret
  if [ -z "${DOCKER_BUILDKIT:-}" ]; then
    echo "Note: BuildKit not explicitly enabled in this shell. You can enable it by prefixing the command:"
    echo "  DOCKER_BUILDKIT=1 ${0} --mode buildkit --secret-file $SECRET_FILE --target $TARGET --tag $TAG"
    echo "Attempting build anyway (may fail if BuildKit not enabled)..."
  fi
fi

# execute build
"${DOCKER_BUILD_CMD[@]}"

BUILD_EXIT=$?

# cleanup
if [ $TMP_REQ_CREATED -eq 1 ]; then
  echo "Removing temporary requirements.txt"
  rm -f requirements.txt
fi

if [ $BUILD_EXIT -ne 0 ]; then
  echo "Build failed with exit code $BUILD_EXIT"
  exit $BUILD_EXIT
fi

echo "Build succeeded: $TAG"
echo "Tips:"
echo " - For private repos prefer buildkit mode with --secret-file and DOCKER_BUILDKIT=1 to avoid leaking tokens."
echo " - If you want to always embed vendor in the image, commit vendor/coinbase_advanced_py to the repo and use --mode local."
